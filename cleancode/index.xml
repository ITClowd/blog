<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CleanCodes on</title><link>https://knowledge.vogel.business/cleancode/</link><description>Recent content in CleanCodes on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://knowledge.vogel.business/cleancode/index.xml" rel="self" type="application/rss+xml"/><item><title>Abstract Factory</title><link>https://knowledge.vogel.business/CleanCode/Abstract-Factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Abstract-Factory/</guid><description>tags: #cleancode/designpatterns
Abstract Factory Intent Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes.</description></item><item><title>Adapter</title><link>https://knowledge.vogel.business/CleanCode/Adapter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Adapter/</guid><description>tags: #cleancode/designpatterns
Adapter Intent Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.
Problem Imagine that you’re creating a stock market monitoring app.</description></item><item><title>Automated Integrationtests</title><link>https://knowledge.vogel.business/CleanCode/Automated-Integrationtests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Automated-Integrationtests/</guid><description>tags: #cleancode
Automated Integrationtests Warum? Integrationstests stellen sicher dass der Code tut was er soll. Diese wiederkehrende Tätigkeit nicht zu automatisieren wäre Zeitverschwendung.</description></item><item><title>Automated Unit Tests</title><link>https://knowledge.vogel.business/CleanCode/Automated-Unit-Tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Automated-Unit-Tests/</guid><description>#cleancode
Automated [[CleanCode/Unit Test|Unit Tests]] Warum? Nur automatisierte Tests werden auch wirklich konsequent ausgeführt. Je punktgenauer sie Code testen, desto besser.</description></item><item><title>Beware of Premature Optimization</title><link>https://knowledge.vogel.business/CleanCode/Beware-of-Premature-Optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Beware-of-Premature-Optimization/</guid><description>#cleancode
Beware of Premature Optimization Warum? Optimierungen kosten immer viel Aufwand. Wer Vorsicht walten lässt, spart oft wertvolle Ressourcen für das, was dem Kunden wirklich nützt.</description></item><item><title>Blauer Grad</title><link>https://knowledge.vogel.business/CleanCode/Blauer-Grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Blauer-Grad/</guid><description>tags: #cleancode
Blauer Grad Prinzipien [[CleanCode/Design and Implementation Don&amp;rsquo;t Overlapp]] [[CleanCode/Implementation Reflects Design]] [[CleanCode/You Ain&amp;rsquo;t Gonna Need It]] Prakiken [[CleanCode/Design before Implementation]] [[CleanCode/Continuous Delivery]] [[CleanCode/Iterative Development]] [[CleanCode/Incremental Development]] [[CleanCode/Component Orientation]] [[CleanCode/Test First]]</description></item><item><title>Boy Scout Rule</title><link>https://knowledge.vogel.business/CleanCode/Boy-Scout-Rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Boy-Scout-Rule/</guid><description>#cleancode
Boy Scout Rule Warum? Jede Beschäftigung mit einem Gegenstand macht ihn zumindest ein klein wenig besser. Ganz ohne bürokratische Planung.</description></item><item><title>Bridge</title><link>https://knowledge.vogel.business/CleanCode/Bridge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Bridge/</guid><description>tags: #cleancode/designpatterns
Bridge Intent Bridge is a [[CleanCode/Design Patterns#Structural|structural design pattern]] that lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.</description></item><item><title>Builder</title><link>https://knowledge.vogel.business/CleanCode/Builder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Builder/</guid><description>tags: #cleancode/designpatterns
Builder Intent Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.</description></item><item><title>Chain of Responsibility</title><link>https://knowledge.vogel.business/CleanCode/Chain-of-Responsibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Chain-of-Responsibility/</guid><description>tags: #cleancode/designpatterns
Chain of Responsibility Intent Chain of Responsibility is a [[CleanCode/Design Patterns#Behavioral|behavioral design pattern]] that lets you pass requests along a chain of handlers.</description></item><item><title>Clean Code</title><link>https://knowledge.vogel.business/CleanCode/Clean-Code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Clean-Code/</guid><description>#cleancode
CleanCode Clean Code sind Praktiken, welche die Qualität des Codes durch BestPractices verbessern sollen.
Die Prinzipien basieren Hauptsächlich auf dem Buch [[Clean Code (Book)]] von [[CleanCode/Robert C.</description></item><item><title>Clean Code Developer</title><link>https://knowledge.vogel.business/CleanCode/Clean-Code-Developer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Clean-Code-Developer/</guid><description>#cleancode
Clean Code Developer Die Grade [[CleanCode/Roter Grad]] [[CleanCode/Orangener Grad]] [[CleanCode/Gelber Grad]] [[CleanCode/Grüner Grad]] [[CleanCode/Blauer Grad]] [[CleanCode/Weißer Grad]] Wertesystem Wandelbarkeit Wir möchten diesen Abschnitt mit einer provokant anmutenden These beginnen:</description></item><item><title>Code Coverage Analysis</title><link>https://knowledge.vogel.business/CleanCode/Code-Coverage-Analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Code-Coverage-Analysis/</guid><description>tags: #cleancode
Code Coverage Analysis Warum? Traue nur Tests, von denen du weißt, dass sie auch wirklich das Testareal abdecken.</description></item><item><title>Code Reviews</title><link>https://knowledge.vogel.business/CleanCode/Code-Reviews/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Code-Reviews/</guid><description>tags: #cleancode
Code Reviews Warum? Vier Augen sehen mehr als zwei. Wenn der eine Entwickler dem anderen seinen Code erklärt, tauchen meist Details auf, die bislang nicht bedacht wurden.</description></item><item><title>Command</title><link>https://knowledge.vogel.business/CleanCode/Command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Command/</guid><description>tags: #cleancode/designpatterns
Command Intent Command is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request.</description></item><item><title>Complex Refactorings</title><link>https://knowledge.vogel.business/CleanCode/Complex-Refactorings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Complex-Refactorings/</guid><description>tags: #cleancode
Complex Refactorings Warum? Es ist nicht möglich, Code direkt in der ultimativen Form zu schreiben.
Bereits im[[CleanCode/Roter Grad|roten Grad]] sind einfache [[CleanCode/Refaktorisieren|Refaktorisierungen]] eingeführt worden.</description></item><item><title>Component Orientation</title><link>https://knowledge.vogel.business/CleanCode/Component-Orientation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Component-Orientation/</guid><description>tags: #cleancode
Component Orientation Warum? Software braucht Black-Box-Bausteine, die sich parallel entwickeln und testen lassen. Das fördert Wandelbarkeit, Produktivität und Korrektheit.</description></item><item><title>Composite</title><link>https://knowledge.vogel.business/CleanCode/Composite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Composite/</guid><description>tags: #cleancode/designpatterns
Composite Intent Composite is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.</description></item><item><title>Continuous Delivery</title><link>https://knowledge.vogel.business/CleanCode/Continuous-Delivery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Continuous-Delivery/</guid><description>tags: #cleancode
Continuous Delivery Warum? Als [[CleanCode/Clean Code Developer]] möchte ich sicher sein, dass ein Setup das Produkt korrekt installiert.</description></item><item><title>Continuous Integration</title><link>https://knowledge.vogel.business/CleanCode/Continuous-Integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Continuous-Integration/</guid><description>tags: #cleancode
Continuous Integration Warum? Automatisierung und Zentralisierung der Softwareproduktion machen produktiver und reduzieren das Risiko von Fehlern bei der Auslieferung.</description></item><item><title>Daily Reflection</title><link>https://knowledge.vogel.business/CleanCode/Daily-Reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Daily-Reflection/</guid><description>#cleancode
Daily Reflection Warum? Keine Verbesserung, kein Fortschritt, kein Lernen ohne Reflexion. Aber nur, wenn Reflexion auch eingeplant wird, findet sie unter dem Druck des Tagesgeschäftes auch statt.</description></item><item><title>Decorator</title><link>https://knowledge.vogel.business/CleanCode/Decorator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Decorator/</guid><description>tags: #cleancode/designpatterns
Decorator Intent Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</description></item><item><title>Dependency Inversion Principle</title><link>https://knowledge.vogel.business/CleanCode/Dependency-Inversion-Principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Dependency-Inversion-Principle/</guid><description>#cleancode
Dependency Inversion Principle (DIP) [!question] Warum? Punktgenaues Testen setzt Isolation von Klassen voraus. Isolation entsteht, wenn Klassen keine Abhängigkeiten von Implementationen mehr enthalten – weder zur Laufzeit, noch zur Übersetzungszeit.</description></item><item><title>Design and Implementation Don't Overlapp</title><link>https://knowledge.vogel.business/CleanCode/Design-and-Implementation-Dont-Overlapp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Design-and-Implementation-Dont-Overlapp/</guid><description>tags: #cleancode
Design and Implementation Don’t Overlapp Warum? Planungsunterlagen, die mit der Umsetzung nichts mehr gemein haben, schaden mehr, als dass sie nützen.</description></item><item><title>Design before Implementation</title><link>https://knowledge.vogel.business/CleanCode/Design-before-Implementation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Design-before-Implementation/</guid><description>tags: #cleancode
Design before Implementation Warum? Vor der Umsetzung muss eine Lösung entworfen werden. Andernfalls findet kein konsequentes Nachdenken über die Lösung statt.</description></item><item><title>Design Patterns</title><link>https://knowledge.vogel.business/CleanCode/Design-Patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Design-Patterns/</guid><description>tags: #cleancode/designpatterns #cleancode/refactoring
Design Patterns Design patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code</description></item><item><title>DRY</title><link>https://knowledge.vogel.business/CleanCode/DRY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/DRY/</guid><description>#cleancode
Don’t Repeat Yourself (DRY) Warum? Jede Doppelung von Code oder Handgriffen leistet Inkonsistenzen und Fehlern Vorschub.
Das DRY-Prinzip lautet: Don’t Repeat Yourself – Wiederhole dich nicht.</description></item><item><title>Error Measurement</title><link>https://knowledge.vogel.business/CleanCode/Error-Measurement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Error-Measurement/</guid><description>tags: #cleancode
Error Measurement Warum? Nur wer weiß, wie viele Fehler auftreten, kann sein Vorgehen so verändern, dass die Fehlerrate sinkt.</description></item><item><title>Facade</title><link>https://knowledge.vogel.business/CleanCode/Facade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Facade/</guid><description>tags: #cleancode/designpatterns
Facade Intent Facade is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.</description></item><item><title>Factory</title><link>https://knowledge.vogel.business/CleanCode/Factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Factory/</guid><description>#cleancode/designpatterns
Factory Intent Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.</description></item><item><title>Favour Composition over Inheritance</title><link>https://knowledge.vogel.business/CleanCode/Favour-Composition-over-Inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Favour-Composition-over-Inheritance/</guid><description>#cleancode
Favour Composition over Inheritance (FCoI) Warum? Komposition fördert die lose Kopplung und die Testbarkeit eines Systems und ist oft flexibler.</description></item><item><title>Flyweight</title><link>https://knowledge.vogel.business/CleanCode/Flyweight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Flyweight/</guid><description>tags: #cleancode/designpatterns
Flyweight Intent Flyweight is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.</description></item><item><title>Gelber Grad</title><link>https://knowledge.vogel.business/CleanCode/Gelber-Grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Gelber-Grad/</guid><description>#cleancode
Gelber Grad Prinzipien [[CleanCode/Interface Segragation Principle]] [[CleanCode/Dependency Inversion Principle]] [[CleanCode/Liskov Substitution Principle]] [[CleanCode/Principle of Least Astonishment]] [[CleanCode/Information Hiding Principle]] Praktiken [[CleanCode/Automated Unit Tests]] [[CleanCode/Mockups]] [[CleanCode/Code Coverage Analysis]] [[CleanCode/Partizipation in Professional Events]] [[CleanCode/Complex Refactorings]]</description></item><item><title>Grüner Grad</title><link>https://knowledge.vogel.business/CleanCode/Gr%C3%BCner-Grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Gr%C3%BCner-Grad/</guid><description>#cleancode
Grüner Grad Prinzipien [[CleanCode/Open Closed Principle]] [[CleanCode/Tell, don&amp;rsquo;t ask]] [[CleanCode/Law of Demeter]] Praktiken [[CleanCode/Continuous Integration]] [[CleanCode/Statical Code Analysis]] [[CleanCode/Inversion of Control Container]] [[CleanCode/Share Experience]] [[CleanCode/Error Measurement]]</description></item><item><title>Implementation Reflects Design</title><link>https://knowledge.vogel.business/CleanCode/Implementation-Reflects-Design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Implementation-Reflects-Design/</guid><description>tags: #cleancode
Implementation Reflects Design Warum? Umsetzung, die von der Planung beliebig abweichen kann, führt direkt in die Unwartbarkeit. Umsetzung braucht daher einen durch die Planung vorgegebenen physischen Rahmen.</description></item><item><title>Incremental Development</title><link>https://knowledge.vogel.business/CleanCode/Incremental-Development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Incremental-Development/</guid><description>tags: #cleancode
Incremental Development Warum? Nur die Arbeit in Inkrementen ermöglicht es dem Product Owner, Feedback zu geben.
Ein Inkrement stellt einen vertikalen Schnitt durch die verschiedenen Aspekte eines Softwaresystems dar.</description></item><item><title>Information Hiding Principle</title><link>https://knowledge.vogel.business/CleanCode/Information-Hiding-Principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Information-Hiding-Principle/</guid><description>#cleancode
Information Hiding Principle Warum? Durch das Verbergen von Details in einer Schnittstelle werden die Abhängigkeiten reduziert.
Beim Design einer Schnittstelle sollte man sich fragen, welche Details außen unbedingt sichtbar sein müssen.</description></item><item><title>Integration Operation Segregation Principle (IOSP)</title><link>https://knowledge.vogel.business/CleanCode/Integration-Operation-Segregation-Principle-IOSP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Integration-Operation-Segregation-Principle-IOSP/</guid><description>#cleancode
Integration Operation Segregation Principle (IOSP) Warum? Ein deutliches Symptom schlecht wandelbaren Codes sind tiefe Hierarchien funktionaler Abhängigkeit. Sie reduzieren die Verständlichkeit und erschweren automatisierte Tests wie Refactoring.</description></item><item><title>Integration Tests</title><link>https://knowledge.vogel.business/CleanCode/Integration-Tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Integration-Tests/</guid><description>tags: #cleancode
Integration Tests</description></item><item><title>Interface Segragation Principle</title><link>https://knowledge.vogel.business/CleanCode/Interface-Segragation-Principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Interface-Segragation-Principle/</guid><description>#cleancode
Interface Segregation Principle (ISP) [!question] Warum? Leistungsbeschreibungen, die unabhängig von einer konkreten Erfüllung sind, machen unabhängig.
Das Interface Segregation Principle ( ISP) ist ein weiteres [[CleanCode/SOLID]] Prinzip.</description></item><item><title>Inversion of Control Container</title><link>https://knowledge.vogel.business/CleanCode/Inversion-of-Control-Container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Inversion-of-Control-Container/</guid><description>#cleancode
Inversion of Control Container Warum? Nur, was nicht fest verdrahtet ist, kann leichter umkonfiguriert werden.
Bereits im [[CleanCode/Gelber Grad|gelben Grad]] hat der [[CleanCode/Clean Code Developer|CCD]] das [[CleanCode/Dependency Inversion Principle]] kennengelernt.</description></item><item><title>Issue Tracking</title><link>https://knowledge.vogel.business/CleanCode/Issue-Tracking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Issue-Tracking/</guid><description>tags: #cleancode
Issue Tracking Warum? Nur, was man aufschreibt, vergisst man nicht und kann man effektiv delegieren und verfolgen.</description></item><item><title>Iterative Development</title><link>https://knowledge.vogel.business/CleanCode/Iterative-Development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Iterative-Development/</guid><description>tags: #cleancode
Iterative Development Warum? Frei nach von Clausewitz: Kein Entwurf, keine Implementation überlebt den Kontakt mit dem Kunden. Softwareentwicklung tut daher gut daran, ihren Kurs korrigieren zu können.</description></item><item><title>Iterator</title><link>https://knowledge.vogel.business/CleanCode/Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Iterator/</guid><description>tags: #cleancode/designpatterns
Iterator Intent Iterator is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.</description></item><item><title>KISS</title><link>https://knowledge.vogel.business/CleanCode/KISS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/KISS/</guid><description>#cleancode
Keep it simple, stupid (KISS) Warum? Wer mehr tut als das Einfachste, lässt den Kunden warten und macht die Lösung unnötig kompliziert.</description></item><item><title>Law of Demeter</title><link>https://knowledge.vogel.business/CleanCode/Law-of-Demeter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Law-of-Demeter/</guid><description>tags: #cleancode
Law of Demeter Warum? Abhängigkeiten von Objekten über mehrere Glieder einer Dienstleistungskette hinweg führen zu unschön enger Kopplung.</description></item><item><title>Legacy Code</title><link>https://knowledge.vogel.business/CleanCode/Legacy-Code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Legacy-Code/</guid><description>tags: #cleancode/refactoring
Legacy Code</description></item><item><title>Liskov Substitution Principle</title><link>https://knowledge.vogel.business/CleanCode/Liskov-Substitution-Principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Liskov-Substitution-Principle/</guid><description>#cleancode
Liskov Substitution Principle [!question] Warum? Wer mit Erben zu tun hat, möchte keine Überraschungen erleben, wenn er mit Erblassern vertraut ist.</description></item><item><title>Mediator</title><link>https://knowledge.vogel.business/CleanCode/Mediator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Mediator/</guid><description>tags: #cleancode/designpatterns
Mediator Intent Mediator is a behavioral design pattern that lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.</description></item><item><title>Memento</title><link>https://knowledge.vogel.business/CleanCode/Memento/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Memento/</guid><description>tags: #cleancode/designpatterns
Memento Intent Memento is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its implementation.</description></item><item><title>Mockups</title><link>https://knowledge.vogel.business/CleanCode/Mockups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Mockups/</guid><description>#cleancode
Mockups Warum? Ohne Attrappen keine einfach kontrollierbaren Tests.
In der Regel verwenden Komponenten andere Komponenten. Will man eine Komponente isoliert testen, müssen diese Abhängigkeiten abgetrennt werden.</description></item><item><title>Observer</title><link>https://knowledge.vogel.business/CleanCode/Observer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Observer/</guid><description>tags: #cleancode/designpatterns
Observer Intent Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.</description></item><item><title>Open Closed Principle</title><link>https://knowledge.vogel.business/CleanCode/Open-Closed-Principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Open-Closed-Principle/</guid><description>#cleancode
Open Closed Principle (OCP) [!question] Warum? Weil das Risiko, durch neue Features ein bisher fehlerfreies System zu instabilisieren, so gering wie möglich gehalten werden sollte.</description></item><item><title>Orangener Grad</title><link>https://knowledge.vogel.business/CleanCode/Orangener-Grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Orangener-Grad/</guid><description>#cleancode
Orangener Grad Prinzipien [[CleanCode/Single Level of Abstraction]] [[CleanCode/Single Responsibility Principle]] [[CleanCode/Separation of Concerns]] [[CleanCode/Source Code Conventions]] Praktiken [[CleanCode/Issue Tracking]] [[CleanCode/Automated Integrationtests]] [[CleanCode/Read, Read, Read]] [[CleanCode/Code Reviews]]</description></item><item><title>Partizipation in Professional Events</title><link>https://knowledge.vogel.business/CleanCode/Partizipation-in-Professional-Events/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Partizipation-in-Professional-Events/</guid><description>tags: #cleancode
Partizipation in Professional Events Warum? Am besten lernen wir von anderen und in Gemeinschaft.
Um nicht nur „im eigenen Saft zu schmoren“, ist es wichtig, regelmäßig mit anderen Softwareentwicklern zu diskutieren und Erfahrungen auszutauschen.</description></item><item><title>Principle of Least Astonishment</title><link>https://knowledge.vogel.business/CleanCode/Principle-of-Least-Astonishment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Principle-of-Least-Astonishment/</guid><description>#cleancode
Principle of Least Astonishment Warum? Wenn sich eine Komponente überraschenderweise anders verhält als erwartet, wird ihre Anwendung unnötig kompliziert und fehleranfällig.</description></item><item><title>Prototype</title><link>https://knowledge.vogel.business/CleanCode/Prototype/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Prototype/</guid><description>tags: #cleancode/designpatterns
Prototype Intent Prototype is a creational design pattern that lets you copy existing objects without making your code dependent on their classes.</description></item><item><title>Proxy</title><link>https://knowledge.vogel.business/CleanCode/Proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Proxy/</guid><description>tags: #cleancode/designpatterns
Proxy Intent Proxy is a structural design pattern that lets you provide a substitute or placeholder for another object.</description></item><item><title>Read, Read, Read</title><link>https://knowledge.vogel.business/CleanCode/Read-Read-Read/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Read-Read-Read/</guid><description>tags: #cleancode
Read, Read, Read Warum? Lesen bildet!
Lesen bildet – wir sind jedenfalls fest davon überzeugt, dass dies auch für Software-Entwickler gilt.</description></item><item><title>Refaktorisieren</title><link>https://knowledge.vogel.business/CleanCode/Refaktorisieren/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Refaktorisieren/</guid><description>tags: #cleancode/refactoring
Refaktorisieren</description></item><item><title>Robert C. Martin</title><link>https://knowledge.vogel.business/CleanCode/Robert-C.-Martin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Robert-C.-Martin/</guid><description>#cleancode</description></item><item><title>Root Cause Analysis</title><link>https://knowledge.vogel.business/CleanCode/Root-Cause-Analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Root-Cause-Analysis/</guid><description>#cleancode
Root Cause Anaysis Warum? Symptome behandeln bringt vielleicht schnell eine Linderung – langfristig kostet es aber mehr Aufwand. Wer stattdessen unter die Oberfläche von Problemen schaut, arbeitet am Ende effizienter.</description></item><item><title>Roter Grad</title><link>https://knowledge.vogel.business/CleanCode/Roter-Grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Roter-Grad/</guid><description>#cleancode
Roter Grad Prinzipien [[CleanCode/DRY]] [[CleanCode/KISS]] [[CleanCode/Beware of Premature Optimization]] [[CleanCode/Favour Composition over Inheritance]] [[CleanCode/Integration Operation Segregation Principle (IOSP)]] Praktiken [[CleanCode/Boy Scout Rule]] [[CleanCode/Root Cause Analysis]] [[CleanCode/Version Control System]] [[CleanCode/Simple Refactorings]] [[CleanCode/Daily Reflection]]</description></item><item><title>Separation of Concerns</title><link>https://knowledge.vogel.business/CleanCode/Separation-of-Concerns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Separation-of-Concerns/</guid><description>tags: #cleancode
Separation of Concerns (SoC) Warum? Wenn eine Codeeinheit keine klare Aufgabe hat, ist es schwer sie zu verstehen, sie anzuwenden und sie ggf.</description></item><item><title>Share Experience</title><link>https://knowledge.vogel.business/CleanCode/Share-Experience/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Share-Experience/</guid><description>tags: #cleancode
Share Experience Warum? Wer sein Wissen weitergibt, hilft nicht nur anderen, sondern auch sich selbst.
Zu professioneller Arbeit gehört selbstverständlich ein ständig akuelles Wissen.</description></item><item><title>Simple Refactorings</title><link>https://knowledge.vogel.business/CleanCode/Simple-Refactorings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Simple-Refactorings/</guid><description>#cleancode
Simple Refactorings Warum? Code verbessern ist leichter, wenn man typische Verbesserungshandgriffe kennt. Ihre Anwendungsszenarien machen sensibel für Schwachpunkte im eigenen Code.</description></item><item><title>Single Level of Abstraction</title><link>https://knowledge.vogel.business/CleanCode/Single-Level-of-Abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Single-Level-of-Abstraction/</guid><description>tags: #cleancode
Single Level of Abstraction (SLA) Warum? Die Einhaltung eines Abstraktionsniveaus fördert die Lesbarkeit
Eine Codezeile kann auf verschiedenen Abstraktionsniveaus liegen.</description></item><item><title>Single Responsibility Principle</title><link>https://knowledge.vogel.business/CleanCode/Single-Responsibility-Principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Single-Responsibility-Principle/</guid><description>#cleancode
Single Responsibility Principle (SRP) [!question] Warum? Fokus erleichtert das Verständnis. Eine Klasse mit genau einer Aufgabe ist verständlicher als ein Gemischtwarenladen.</description></item><item><title>Singleton</title><link>https://knowledge.vogel.business/CleanCode/Singleton/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Singleton/</guid><description>tags: #cleancode/designpatterns
Singleton Intent Singleton is a [[CleanCode/Design Patterns#Creational|creational design pattern]] that lets you ensure that a class has only one instance, while providing a global access point to this instance.</description></item><item><title>SOLID</title><link>https://knowledge.vogel.business/CleanCode/SOLID/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/SOLID/</guid><description>#cleancode
SOLID The SOLID Principles are a part of the [[CleanCode/Clean Code]] Principles. The letters stand for:
[[CleanCode/Single Responsibility Principle]] [[CleanCode/Open Closed Principle]] [[CleanCode/Liskov Substitution Principle]] [[CleanCode/Interface Segragation Principle]] [[CleanCode/Dependency Inversion Principle]]</description></item><item><title>Source Code Conventions</title><link>https://knowledge.vogel.business/CleanCode/Source-Code-Conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Source-Code-Conventions/</guid><description>tags: #cleancode
Source Code Conventions Warum? Code wird häufiger gelesen als geschrieben. Daher sind Konventionen wichtig, die ein schnelles Lesen und Erfassen des Codes unterstützen.</description></item><item><title>State</title><link>https://knowledge.vogel.business/CleanCode/State/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/State/</guid><description>tags: #cleancode/designpatterns
State Intent State is a behavioral design pattern that lets an object alter its behavior when its internal state changes.</description></item><item><title>Statical Code Analysis</title><link>https://knowledge.vogel.business/CleanCode/Statical-Code-Analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Statical-Code-Analysis/</guid><description>tags: #cleancode
Statical Code Analysis Warum? Vertrauen ist gut, Kontrolle ist besser – und je automatischer, desto leichter ist sie.</description></item><item><title>Strategy</title><link>https://knowledge.vogel.business/CleanCode/Strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Strategy/</guid><description>tags: #cleancode/designpatterns
Strategy Intent Strategy is a [[CleanCode/Design Patterns#Behavioral|behavioral design pattern]] that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.</description></item><item><title>Tell, don't ask</title><link>https://knowledge.vogel.business/CleanCode/Tell-dont-ask/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Tell-dont-ask/</guid><description>tags: #cleancode
Tell, don’t ask Warum? Hohe [[Kohäsion]] und lose Kopplung sind Tugenden. Öffentliche Zustandsdetails einer Klasse widersprechen dem.</description></item><item><title>Template Method</title><link>https://knowledge.vogel.business/CleanCode/Template-Method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Template-Method/</guid><description>tags: #cleancode/designpatterns
Template Method Intent Template Method is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.</description></item><item><title>Test First</title><link>https://knowledge.vogel.business/CleanCode/Test-First/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Test-First/</guid><description>tags: #cleancode
Test First Warum?
Der Kunde ist König und bestimmt die Form einer Dienstleistung. Service-Implementationen sind also nur passgenau, wenn sie durch einen Client getrieben werden.</description></item><item><title>Unit Test</title><link>https://knowledge.vogel.business/CleanCode/Unit-Test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Unit-Test/</guid><description>tags: #cleancode
Unit Test</description></item><item><title>Version Control System</title><link>https://knowledge.vogel.business/CleanCode/Version-Control-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Version-Control-System/</guid><description>#cleancode
Version Control System Warum? Symptome behandeln bringt vielleicht schnell eine Linderung – langfristig kostet es aber mehr Aufwand. Wer stattdessen unter die Oberfläche von Problemen schaut, arbeitet am Ende effizienter.</description></item><item><title>Visitor</title><link>https://knowledge.vogel.business/CleanCode/Visitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Visitor/</guid><description>tags: #cleancode/designpatterns
Visitor Intent Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate.</description></item><item><title>Weißer Grad</title><link>https://knowledge.vogel.business/CleanCode/Wei%C3%9Fer-Grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/Wei%C3%9Fer-Grad/</guid><description>tags: #cleancode
Weißer Grad Vereinigung aller Prinzipien und Praktiken</description></item><item><title>You Ain't Gonna Need It</title><link>https://knowledge.vogel.business/CleanCode/You-Aint-Gonna-Need-It/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://knowledge.vogel.business/CleanCode/You-Aint-Gonna-Need-It/</guid><description>tags: #cleancode
You Ain’t Gonna Need It Warum? Dinge die niemand braucht, haben keinen Wert. Verschwende an sie also keine Zeit.</description></item></channel></rss>